{"version":3,"file":"resolve.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["// This is a clone of `new URL(url, base).href`\n// It is bases on the following RegEx.\n// ^(([^:\\/?#]+):)?(\\/\\/([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n// $1 = http:\n// $2 = http                //protocol\n// $3 = //www.example.com\n// $4 = www.example.com     //domain `undefined` is missing or \"\" if present but blank\n// $5 = /foo/bar/ or foo    //path\n// $6 = ?a=b                //search\n// $7 = a=b\n// $8 = #hash               //hash\n// $9 = hash\n// Note 1: all but $5 will be undefined if missing. $5 will be \"\"\n// Note 2: $5 will be \"undefined\" (the string) if uri is undefined\n// see https://tools.ietf.org/html/rfc3986#appendix-B\n\nconst parseUri = (uri = '') => {\n  const parts = /^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$/i.exec(\n    uri\n  ) as Array<string>;\n  const [\n    ,\n    ,\n    protocol = '', // raw protocol ex: `http`\n    slashslash, // domain with leading `//`\n    domain, // let domain be undefined\n    path,\n    search = '',\n    ,\n    hash = '',\n  ] = parts;\n  return { protocol, slashslash, domain, path, search, hash };\n};\n\n// \"?x=123\", \"http://ex.co/foo\" => \"http://ex.co/foo?x=123\"\nexport const resolve = (url: string, base: string): string => {\n  const u = parseUri(url);\n  const b = parseUri(base);\n\n  const getPath = () => {\n    const searchHash = u.search + u.hash;\n\n    if (u.path.startsWith('/')) {\n      // u is absolute so ignore b\n      return u.path.substr(1) + searchHash; // use u.path w/no leading slash\n    }\n    if (b.path.endsWith('/')) {\n      // u=\"bar/baz/\" b=\"/foo/\" res=\"foo/bar/baz\"\n      return b.path.substr(1) + u.path + searchHash;\n    }\n    if (u.path) {\n      return u.path + searchHash;\n    }\n    if (b.path.startsWith('/')) {\n      return b.path.substr(1) + searchHash; // use u.path w/no leading slash\n    }\n    return b.path + searchHash;\n  };\n\n  const protocol = u.protocol || b.protocol;\n  const domain = u.domain ?? b.domain;\n  if (\n    (u.slashslash === '//' && u.path === '/') ||\n    !base ||\n    !protocol ||\n    domain === undefined\n  ) {\n    // A fully qualified URL *must* have a protocol and a domain\n    throw new TypeError('Invalid base URL');\n  }\n\n  return `${protocol.toLowerCase()}://${domain.toLowerCase()}/${getPath()}`;\n};\n"],"names":["parseUri","uri","parts","exec","protocol","slashslash","domain","path","search","hash","url","base","searchHash","u","b","undefined","TypeError","toLowerCase","startsWith","substr","endsWith"],"mappings":"oEAgBA,IAAMA,EAAW,SAACC,YAAAA,IAAAA,EAAM,QAChBC,EAAQ,gEAAgEC,KAC5EF,KAYEC,OAAAA,OAAAA,WACG,CAAEE,oBARI,KAQMC,WADfH,KAC2BI,OAD3BJ,KACmCK,KADnCL,KACyCM,kBAJlC,KAI0CC,gBAF5C,uBAMY,SAACC,EAAaC,SAK3BC,EAJFC,EAAIb,EAASU,GACbI,EAAId,EAASW,GAsBbP,EAAWS,EAAET,UAAYU,EAAEV,SAC3BE,YAASO,EAAEP,sBAAUQ,EAAER,UAET,OAAjBO,EAAER,YAAkC,MAAXQ,EAAEN,OAC3BI,IACAP,QACUW,IAAXT,QAGM,IAAIU,UAAU,2BAGZZ,EAASa,oBAAmBX,EAAOW,mBA/BrCL,EAAaC,EAAEL,OAASK,EAAEJ,KAE5BI,EAAEN,KAAKW,WAAW,KAEbL,EAAEN,KAAKY,OAAO,GAAKP,EAExBE,EAAEP,KAAKa,SAAS,KAEXN,EAAEP,KAAKY,OAAO,GAAKN,EAAEN,KAAOK,EAEjCC,EAAEN,KACGM,EAAEN,KAAOK,EAEdE,EAAEP,KAAKW,WAAW,KACbJ,EAAEP,KAAKY,OAAO,GAAKP,EAErBE,EAAEP,KAAOK"}