{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n}); // This is a clone of `new URL(url, base).href`\n// It is bases on the following RegEx.\n// ^(([^:\\/?#]+):)?(\\/\\/([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n// $1 = http:\n// $2 = http                //protocol\n// $3 = //www.example.com\n// $4 = www.example.com     //domain `undefined` is missing or \"\" if present but blank\n// $5 = /foo/bar/ or foo    //path\n// $6 = ?a=b                //search\n// $7 = a=b\n// $8 = #hash               //hash\n// $9 = hash\n// Note 1: all but $5 will be undefined if missing. $5 will be \"\"\n// Note 2: $5 will be \"undefined\" (the string) if uri is undefined\n// see https://tools.ietf.org/html/rfc3986#appendix-B\n\nvar parseUri = function parseUri(uri) {\n  if (uri === void 0) {\n    uri = '';\n  }\n\n  var parts = /^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$/i.exec(uri);\n  var _parts$ = parts[2],\n      protocol = _parts$ === void 0 ? '' : _parts$,\n      // raw protocol ex: `http`\n  slashslash = parts[3],\n      // domain with leading `//`\n  domain = parts[4],\n      // let domain be undefined\n  path = parts[5],\n      _parts$2 = parts[6],\n      search = _parts$2 === void 0 ? '' : _parts$2,\n      _parts$3 = parts[8],\n      hash = _parts$3 === void 0 ? '' : _parts$3;\n  return {\n    protocol: protocol,\n    slashslash: slashslash,\n    domain: domain,\n    path: path,\n    search: search,\n    hash: hash\n  };\n}; // \"?x=123\", \"http://ex.co/foo\" => \"http://ex.co/foo?x=123\"\n\n\nvar resolve = function resolve(url, base) {\n  var _u$domain;\n\n  var u = parseUri(url);\n  var b = parseUri(base);\n\n  var getPath = function getPath() {\n    var searchHash = u.search + u.hash;\n\n    if (u.path.startsWith('/')) {\n      // u is absolute so ignore b\n      return u.path.substr(1) + searchHash; // use u.path w/no leading slash\n    }\n\n    if (b.path.endsWith('/')) {\n      // u=\"bar/baz/\" b=\"/foo/\" res=\"foo/bar/baz\"\n      return b.path.substr(1) + u.path + searchHash;\n    }\n\n    if (u.path) {\n      return u.path + searchHash;\n    }\n\n    if (b.path.startsWith('/')) {\n      return b.path.substr(1) + searchHash; // use u.path w/no leading slash\n    }\n\n    return b.path + searchHash;\n  };\n\n  var protocol = u.protocol || b.protocol;\n  var domain = (_u$domain = u.domain) !== null && _u$domain !== void 0 ? _u$domain : b.domain;\n\n  if (u.slashslash === '//' && u.path === '/' || !base || !protocol || domain === undefined) {\n    // A fully qualified URL *must* have a protocol and a domain\n    throw new TypeError('Invalid base URL');\n  }\n\n  return protocol.toLowerCase() + \"://\" + domain.toLowerCase() + \"/\" + getPath();\n};\n\nexports.resolve = resolve;","map":{"version":3,"mappings":";;;;IAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAMA,QAAQ,GAAG,SAAXA,QAAW,CAACC,GAAD;MAACA;AAAAA,UAAM,EAANA;;;AAChB,MAAMC,KAAK,GAAG,gEAAgEC,IAAhE,CACZF,GADY,CAAd;gBAaIC;MAPFE,gCAAW,EAAXA,GAAWC;;AACXC,eAMEJ;;AALFK,WAKEL;;AAJFM,SAIEN;iBAAAA;MAHFO,+BAAS,EAATA,GAASC;iBAGPR;MADFS,6BAAO,EAAPA,GAAOC;AAET,SAAO;AAAER,YAAQ,EAARA,QAAF;AAAYE,cAAU,EAAVA,UAAZ;AAAwBC,UAAM,EAANA,MAAxB;AAAgCC,QAAI,EAAJA,IAAhC;AAAsCC,UAAM,EAANA,MAAtC;AAA8CE,QAAI,EAAJA;AAA9C,GAAP;AAfF,E,CAAA;;;IAmBaE,OAAO,GAAG,SAAVA,OAAU,CAACC,GAAD,EAAcC,IAAd;;;AACrB,MAAMC,CAAC,GAAGhB,QAAQ,CAACc,GAAD,CAAlB;AACA,MAAMG,CAAC,GAAGjB,QAAQ,CAACe,IAAD,CAAlB;;AAEA,MAAMG,OAAO,GAAG,SAAVA,OAAU;AACd,QAAMC,UAAU,GAAGH,CAAC,CAACP,MAAFO,GAAWA,CAAC,CAACL,IAAhC;;AAEA,QAAIK,CAAC,CAACR,IAAFQ,CAAOI,UAAPJ,CAAkB,GAAlBA,CAAJ,EAA4B;AAC1B;AACA,aAAOA,CAAC,CAACR,IAAFQ,CAAOK,MAAPL,CAAc,CAAdA,IAAmBG,UAA1B,CAF0B;AAG3B;;AACD,QAAIF,CAAC,CAACT,IAAFS,CAAOK,QAAPL,CAAgB,GAAhBA,CAAJ,EAA0B;AACxB;AACA,aAAOA,CAAC,CAACT,IAAFS,CAAOI,MAAPJ,CAAc,CAAdA,IAAmBD,CAAC,CAACR,IAArBS,GAA4BE,UAAnC;AACD;;AACD,QAAIH,CAAC,CAACR,IAAN,EAAY;AACV,aAAOQ,CAAC,CAACR,IAAFQ,GAASG,UAAhB;AACD;;AACD,QAAIF,CAAC,CAACT,IAAFS,CAAOG,UAAPH,CAAkB,GAAlBA,CAAJ,EAA4B;AAC1B,aAAOA,CAAC,CAACT,IAAFS,CAAOI,MAAPJ,CAAc,CAAdA,IAAmBE,UAA1B,CAD0B;AAE3B;;AACD,WAAOF,CAAC,CAACT,IAAFS,GAASE,UAAhB;AAjBF;;AAoBA,MAAMf,QAAQ,GAAGY,CAAC,CAACZ,QAAFY,IAAcC,CAAC,CAACb,QAAjC;AACA,MAAMG,MAAM,gBAAGS,CAAC,CAACT,MAAL,iDAAeU,CAAC,CAACV,MAA7B;;AACA,MACGS,CAAC,CAACV,UAAFU,KAAiB,IAAjBA,IAAyBA,CAAC,CAACR,IAAFQ,KAAW,GAApCA,IACD,CAACD,IADAC,IAED,CAACZ,QAFAY,IAGDT,MAAM,KAAKgB,SAJb,EAKE;AACA;AACA,UAAM,IAAIC,SAAJ,CAAc,kBAAd,CAAN;AACD;;AAED,SAAUpB,QAAQ,CAACqB,WAATrB,KAAV,KAAUA,GAA4BG,MAAM,CAACkB,WAAPlB,EAA5BH,GAAV,GAAUA,GAAoDc,OAAO,EAArE;AACD","names":["parseUri","uri","parts","exec","protocol","_parts$","slashslash","domain","path","search","_parts$2","hash","_parts$3","resolve","url","base","u","b","getPath","searchHash","startsWith","substr","endsWith","undefined","TypeError","toLowerCase"],"sources":["/Users/vitto/Documents/PERSONAL/intern/meyd.it/client/node_modules/@thwack/resolve/src/index.ts"],"sourcesContent":["// This is a clone of `new URL(url, base).href`\n// It is bases on the following RegEx.\n// ^(([^:\\/?#]+):)?(\\/\\/([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n// $1 = http:\n// $2 = http                //protocol\n// $3 = //www.example.com\n// $4 = www.example.com     //domain `undefined` is missing or \"\" if present but blank\n// $5 = /foo/bar/ or foo    //path\n// $6 = ?a=b                //search\n// $7 = a=b\n// $8 = #hash               //hash\n// $9 = hash\n// Note 1: all but $5 will be undefined if missing. $5 will be \"\"\n// Note 2: $5 will be \"undefined\" (the string) if uri is undefined\n// see https://tools.ietf.org/html/rfc3986#appendix-B\n\nconst parseUri = (uri = '') => {\n  const parts = /^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$/i.exec(\n    uri\n  ) as Array<string>;\n  const [\n    ,\n    ,\n    protocol = '', // raw protocol ex: `http`\n    slashslash, // domain with leading `//`\n    domain, // let domain be undefined\n    path,\n    search = '',\n    ,\n    hash = '',\n  ] = parts;\n  return { protocol, slashslash, domain, path, search, hash };\n};\n\n// \"?x=123\", \"http://ex.co/foo\" => \"http://ex.co/foo?x=123\"\nexport const resolve = (url: string, base: string): string => {\n  const u = parseUri(url);\n  const b = parseUri(base);\n\n  const getPath = () => {\n    const searchHash = u.search + u.hash;\n\n    if (u.path.startsWith('/')) {\n      // u is absolute so ignore b\n      return u.path.substr(1) + searchHash; // use u.path w/no leading slash\n    }\n    if (b.path.endsWith('/')) {\n      // u=\"bar/baz/\" b=\"/foo/\" res=\"foo/bar/baz\"\n      return b.path.substr(1) + u.path + searchHash;\n    }\n    if (u.path) {\n      return u.path + searchHash;\n    }\n    if (b.path.startsWith('/')) {\n      return b.path.substr(1) + searchHash; // use u.path w/no leading slash\n    }\n    return b.path + searchHash;\n  };\n\n  const protocol = u.protocol || b.protocol;\n  const domain = u.domain ?? b.domain;\n  if (\n    (u.slashslash === '//' && u.path === '/') ||\n    !base ||\n    !protocol ||\n    domain === undefined\n  ) {\n    // A fully qualified URL *must* have a protocol and a domain\n    throw new TypeError('Invalid base URL');\n  }\n\n  return `${protocol.toLowerCase()}://${domain.toLowerCase()}/${getPath()}`;\n};\n"]},"metadata":{},"sourceType":"script"}