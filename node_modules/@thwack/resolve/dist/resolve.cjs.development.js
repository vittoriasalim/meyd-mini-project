'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

// This is a clone of `new URL(url, base).href`
// It is bases on the following RegEx.
// ^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
// $1 = http:
// $2 = http                //protocol
// $3 = //www.example.com
// $4 = www.example.com     //domain `undefined` is missing or "" if present but blank
// $5 = /foo/bar/ or foo    //path
// $6 = ?a=b                //search
// $7 = a=b
// $8 = #hash               //hash
// $9 = hash
// Note 1: all but $5 will be undefined if missing. $5 will be ""
// Note 2: $5 will be "undefined" (the string) if uri is undefined
// see https://tools.ietf.org/html/rfc3986#appendix-B
var parseUri = function parseUri(uri) {
  if (uri === void 0) {
    uri = '';
  }

  var parts = /^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/i.exec(uri);
  var _parts$ = parts[2],
      protocol = _parts$ === void 0 ? '' : _parts$,
      // raw protocol ex: `http`
  slashslash = parts[3],
      // domain with leading `//`
  domain = parts[4],
      // let domain be undefined
  path = parts[5],
      _parts$2 = parts[6],
      search = _parts$2 === void 0 ? '' : _parts$2,
      _parts$3 = parts[8],
      hash = _parts$3 === void 0 ? '' : _parts$3;
  return {
    protocol: protocol,
    slashslash: slashslash,
    domain: domain,
    path: path,
    search: search,
    hash: hash
  };
}; // "?x=123", "http://ex.co/foo" => "http://ex.co/foo?x=123"


var resolve = function resolve(url, base) {
  var _u$domain;

  var u = parseUri(url);
  var b = parseUri(base);

  var getPath = function getPath() {
    var searchHash = u.search + u.hash;

    if (u.path.startsWith('/')) {
      // u is absolute so ignore b
      return u.path.substr(1) + searchHash; // use u.path w/no leading slash
    }

    if (b.path.endsWith('/')) {
      // u="bar/baz/" b="/foo/" res="foo/bar/baz"
      return b.path.substr(1) + u.path + searchHash;
    }

    if (u.path) {
      return u.path + searchHash;
    }

    if (b.path.startsWith('/')) {
      return b.path.substr(1) + searchHash; // use u.path w/no leading slash
    }

    return b.path + searchHash;
  };

  var protocol = u.protocol || b.protocol;
  var domain = (_u$domain = u.domain) !== null && _u$domain !== void 0 ? _u$domain : b.domain;

  if (u.slashslash === '//' && u.path === '/' || !base || !protocol || domain === undefined) {
    // A fully qualified URL *must* have a protocol and a domain
    throw new TypeError('Invalid base URL');
  }

  return protocol.toLowerCase() + "://" + domain.toLowerCase() + "/" + getPath();
};

exports.resolve = resolve;
//# sourceMappingURL=resolve.cjs.development.js.map
